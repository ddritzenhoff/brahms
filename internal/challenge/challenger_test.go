package challenge

import (
	"bytes"
	"testing"
)

var testIdentity = []byte{0x00, 0x01, 0x02, 0x03}

func TestChallenger_NewChallenge(t *testing.T) {
	t.Parallel()
	t.Run("challenge is created using most recent hash", func(t *testing.T) {
		exampleKey := make([]byte, 64)
		for i := range exampleKey {
			exampleKey[i] = 0x12
		}
		ch := Challenger{keyRotation: [][]byte{exampleKey}}

		res, err := ch.NewChallenge(testIdentity)
		if err != nil {
			t.Error(err)
		}
		if !bytes.Equal(res, []byte{0x03, 0x14, 0x15, 0x6A, 0x7A, 0x91, 0x9F, 0x57, 0x8F, 0x8A, 0xC8, 0x68, 0xF7, 0xBA,
			0x3D, 0x5D, 0xBA, 0xE0, 0x64, 0xDD, 0x26, 0x7A, 0x6D, 0xA9, 0x2D, 0xA2, 0x41, 0x1A, 0x20, 0x1C, 0x05, 0x5B}) {
			t.Error("created challenge is not equal to the expected one: ", res)
		}
	})
}

func TestChallenger_IsSolvedCorrectly(t *testing.T) {
	t.Parallel()
	t.Run("solved challenged is accepted as correct", func(t *testing.T) {
		exampleKey := make([]byte, 64)
		for i := range exampleKey {
			exampleKey[i] = 0x12
		}
		ch := Challenger{keyRotation: [][]byte{exampleKey}}

		challenge := []byte{0x03, 0x14, 0x15, 0x6A, 0x7A, 0x91, 0x9F, 0x57, 0x8F, 0x8A, 0xC8, 0x68, 0xF7, 0xBA,
			0x3D, 0x5D, 0xBA, 0xE0, 0x64, 0xDD, 0x26, 0x7A, 0x6D, 0xA9, 0x2D, 0xA2, 0x41, 0x1A, 0x20, 0x1C, 0x05, 0x5B}
		solution := []byte{0x00, 0x00, 0x00, 0x00, 0x02, 0x06, 0x3B, 0xBC}

		correct, err := ch.IsSolvedCorrectly(challenge, solution, testIdentity, 28)
		if err != nil {
			t.Error(err)
		}
		if !correct {
			t.Error("correct solution is not recognized")
		}
	})

	t.Run("incorrect challenge solution is denied", func(t *testing.T) {
		exampleKey := make([]byte, 64)
		for i := range exampleKey {
			exampleKey[i] = 0x12
		}
		ch := Challenger{keyRotation: [][]byte{exampleKey}}

		challenge := []byte{0x03, 0x14, 0x15, 0x6A, 0x7A, 0x91, 0x9F, 0x57, 0x8F, 0x8A, 0xC8, 0x68, 0xF7, 0xBA,
			0x3D, 0x5D, 0xBA, 0xE0, 0x64, 0xDD, 0x26, 0x7A, 0x6D, 0xA9, 0x2D, 0xA2, 0x41, 0x1A, 0x20, 0x1C, 0x05, 0x5B}
		solution := []byte{0x00, 0x00, 0x00, 0x00, 0x02, 0x06, 0x3C, 0xBB}

		correct, err := ch.IsSolvedCorrectly(challenge, solution, testIdentity, 28)
		if err != nil {
			t.Error(err)
		}
		if correct {
			t.Error("incorrect solution is accepted")
		}
	})

	t.Run("challenge solution with insufficient difficulty is denied", func(t *testing.T) {
		exampleKey := make([]byte, 64)
		for i := range exampleKey {
			exampleKey[i] = 0x12
		}
		ch := Challenger{keyRotation: [][]byte{exampleKey}}

		challenge := []byte{0x03, 0x14, 0x15, 0x6A, 0x7A, 0x91, 0x9F, 0x57, 0x8F, 0x8A, 0xC8, 0x68, 0xF7, 0xBA,
			0x3D, 0x5D, 0xBA, 0xE0, 0x64, 0xDD, 0x26, 0x7A, 0x6D, 0xA9, 0x2D, 0xA2, 0x41, 0x1A, 0x20, 0x1C, 0x05, 0x5B}
		solution := []byte{0x00, 0x00, 0x00, 0x00, 0x02, 0x06, 0x3B, 0xBC}

		correct, err := ch.IsSolvedCorrectly(challenge, solution, testIdentity, 42)
		if err != nil {
			t.Error(err)
		}
		if correct {
			t.Error("incorrect solution is accepted")
		}
	})
}
